---
title: "Guide for Snakemake installation and implementation"
author: "Martina"
date: "2025-04-30"
output:
  html_document: default
  pdf_document: default
---

# 1. Snakemake

Snakemake follows the GNU Make paradigm: workflows are defined in terms of rules that define how to create output files from input files. Dependencies between the rules are determined automatically, creating a DAG (directed acyclic graph) of jobs that can be automatically parallelized.

reference: https://snakemake.readthedocs.io/en/stable/tutorial/tutorial.html


# 2. Snakemake Installation (in personal computer): 

## 2.1. Python Installation:

For snakemake installation Python is required to be installed. If that's not the case visit this website for downloading it: https://www.python.org/downloads/windows/
During Python installation mark add python to the path option. 

## 2.2. Snakemake Installation:

Once python is installed snakemake can be installed by running the following line in your personal computer terminal: 

```{bash eval=FALSE}
pip install snakemake[reports]
```


Since we're going to Use R markdown we need both R and Rstudio installed and also Pandoc for reading the Rmarkdown. Make sure that both R and R studio are added to the path. If you want to check if that's the case run the following command in your terminal: 

```{bash eval=FALSE}
Rscript --version
```

## 2.3. Pandoc Installation: 

For Pandoc installation follow the following link, download the installer and execute it: https://pandoc.org/installing.html

## 2.4. Graphviz installation:

Finally in case we want to generate the DAGs (Directed Acyclic Graph) we will also need to install Graphviz: https://graphviz.org/download/. Make sure to add the Graphviz to the path during the installation. 

Once all the programs have been correctly installed we can proceed with the setup for Snakemake to work. 

# 3. Snakemkae installation (via conda): 

In the following link there's the explanation on how to install snakemake via conda. We will follow the miniforge route. 

https://snakemake.readthedocs.io/en/stable/getting_started/installation.html

The steps willa lso be explained in the following parts: 

## 3.1. Install conda via miniforge : 

For installing miniforge and conda we follow the miniforge link: https://github.com/conda-forge/miniforge

Then we follow the instruccions in the Install section in the part that says: Install as a part of a CI pipeline. 

Once conda is installed we will be able to activate it via: 

```{bash eval=FALSE}
conada activate
```

## 3.2. Install Snakemake via conda: 

Snakemake can be installed with all goodies needed to run in any environment and for creating interactive reports via

```{bash eval=FALSE}
conda create -c conda-forge -c bioconda -n snakemake snakemake
```

From the Bioconda channel. This will install snakemake into an isolated software environment, that has to be activated with

```{bash eval=FALSE}
conda activate snakemake
snakemake --help  #to check that it has been correctly installed 
```

Installing into isolated environments is best practice in order to avoid side effects with other packages. In my case I've installed the environment in the folder that i want to work on: snakefile_trial. From now on every time i want to work on that I move there via cd and then activate the environment via conda activate snakemake. 

## 3.3. Install pandoc via conda

Once you're in you're snakemake environment and is activated, we can install other programs that are needed for running Rmarkdowns via snakemake, like pandoc. 

```{bash eval=FALSE}
conda install -c condaforge pandoc
```

## 3.4. Install Graphiz 

In the same snakemake environment we also install Graphiz to be bale to build dags. 

```{bash eval=FALSE}
sudo apt install graphviz
```


# 4. Snakemake setup:

## 4.1. Folder Structure

In one main folder where we will be working, we will create 2 folders: 

- Input (where we will store the input data)
- Output (where the output files will be saved)


This main folder is the localization where we have to be to run all the snakemake commands. This main folder will contain the Snakefile, the configfile and teh scripts. 


## 4.2. Config file writing and structure: 

For creating a config file we can just create a txt file and later transformed it to yaml. for doing that we just open a txt file and saved it as config.txt then using this command we can saved as yaml which is the format that snakemake reads. 

```{bash eval=FALSE}
Rename-Item "config.txt" "config.yaml"
```

The interior of the config file need to contain all the parameters that you want to be able to edit when implementing the pipeline. Here we have an example on how it can look like:  

```{python eval=FALSE}
filtering_versions:
  mt5:
    min_features: 200
    max_features: 2500
    max_percent_mt: 5
  mt10:
    min_features: 200
    max_features: 2500
    max_percent_mt: 10


n_features: 2000

pca: 15
```

In this case in the first script we want two versions to be runned one with mt5 and the other with mt10 so for that the two folders are specified with the other parameters. This will have to also be accounted on the snakefile where you will specify if you want the default to create the two versions or just one of them. 

## 4.3. Snakefile writing and structure:

The Snakefile is the core of the Snakemake workflow. It defines each step of the pipeline using rules, which describe how to transform input files into output files. Each rule typically includes:

-input: the files or parameters required

-output: the files that will be generated

-params: additional parameters (like numbers from a config file)

-shell: the actual command that gets run

### 4.3.1. Example Structure: Multiple Versions via Config File

In the config example we're running the pipeline for two versions: mt5 and mt10, which are defined in the config.yaml. This lets you dynamically generate outputs based on different parameter values.

Here’s how the Snakefile is structured:

CONFIGFILE
```{python eval=FALSE}

configfile: "config.yaml"
```

RULE ALL: 

This is the default rule, which means Snakemake will aim to produce these outputs by default. It uses expand() to iterate over all versions (mt5, mt10) and create the appropriate file paths.
```{python eval=FALSE}
rule all:
    input:
        expand("output/{version}/clustering.html", version=config["filtering_versions"].keys()),
        expand("output/{version}/clustering.rds", version=config["filtering_versions"].keys())
```

A RULE EXEMAPLE: 

wildcards.version allows Snakemake to plug in mt5 or mt10 automatically (or whatever name you specified for he versions in the config_file)

The params field dynamically builds the parameter string passed to the R Markdown file. This parameter string is obtained thanks to items() that takes all the parameters specified in the config file under that version. That way each version is processed with its corresponding parameters from config.yaml.

```{python eval=FALSE}
rule filtering_QC:
    input:
        rmd="1-Filtering_QC.Rmd",
        data_dir="input/filtered_gene_bc_matrices/hg19"
    output:
        html="output/{version}/filter_qc.html",
        rds="output/{version}/filtered_pbmc.rds"
    params:
        filtering_params = lambda wildcards: ", ".join(f"{k}={v}" for k, v in config["filtering_versions"][wildcards.version].items())
    shell:
        """
        Rscript -e "rmarkdown::render('{input.rmd}', output_file='{output.html}', params=list(data_dir='{input.data_dir}', output_rds='{output.rds}', {params.filtering_params}))"
        """

```


OTHER RULES: 

More rules can be added and will follow the same structure as the previous rule. 



### Key Concepts Illustrated:

-Modularity: Each rule performs a clear step.

-Reproducibility: Parameters are tracked in config.yaml.

-Scalability: Adding a new version (e.g., mt15) just requires updating config.yaml.

-Reusability: Each rule uses R Markdown, allowing transparent data reporting and analysis.




## 4.4. R markdown Adaptation for Snakemake: 

For a R markdown to run using snakefile we need to select first what parameters we want to fix in the script and which ones we want to be editable via the config file. This parameters along with the inputs localization and outputs need to be specified in the beginning looking like this: 

```{r eval=FALSE}

title: "Filtering and QC"
output: html_document
date: "2025-04-23"
params:
  data_dir: "input/"
  output_rds: "output/filtered_pbmc.rds"
  min_feat: 200
  max_feat: 2500
  max_mt: 5


```

Then after that we need to edit/write the R markdown so instead of using directly numbers for the parameters it's using the names specified for instance min_feat. 

Note: when we initialize the parameters, min_feat for example, we set a default number 200 in this case, but if the config file contains a different number set that number will be used. 

# 5. Snakefile Usage: 

A Snakefile is characterized by a set of rule that are executed depending on the command used. There's a master rule, called rule all, this rule specifies what is the default, and if nothing else is specified when the command snakemake is runned it's the rule that will be applied. You also need to specify the number of cores you will be assigning to the task. 

```{bash eval=FALSE}
snakemake --cores 1
```

If this command is runned only the rules needed to achieve the outputs stated in the rule all rule will be executed, But if you want to only run a certain specific rule you can either do the command specifying the rule (first example) or a command specifying the output that you want (second example). In the case of using the specific output you need to specify the relative route to teh place where the snakefile is. 

```{bash eval=FALSE}
snakemake filtering_QC --cores 1
```

```{bash eval=FALSE}
snakemake output/filtered_pbmc.rds --cores 1
```


# 6. Other useful things:

## 6.1. How to build a DAG: 

The complete DAG:
```{bash eval=FALSE}
snakemake --dag | dot -Tpdf -o dag.pdf
```

The partial DAG (there's the possibility to have only the representation to a certain file object) 

```{bash eval=FALSE}
snakemake write/your/output/file --dag | dot -Tpdf -o dag_parcial.pdf
```

## 6.2. To change file names

```{bash eval=FALSE}
Rename-Item "config.yaml.txt" "config.yaml"
```

## 6.3. How to configure git:

For having all the scripts,snakefile and config file saved and tracked git can be used. For that make sure that you create a gitignore file called: .gitignore that specifies what to ignore from the snakefile folder like input or output data. It can look something like this: 

```{python eval=FALSE}
# Ignore input and output data
input/
output/

# Ignore Snakemake's working directory
.snakemake/

# Ignore logs (if you have a logs/ folder)
logs/

# Ignore DAG files (optional)
*.dag
*.dot
*.png
```

Once the gitignore file is created you can link your main folder with the sankefile to your git project. 

### 6.4. Conatiner Usage: 

You can use containers by either specifying different containers for each rule or in the case you want to use the same conatiner for all the rules you can specify it at the top of the snakefile: 

```{python eval=FALSE}
# Set a global container for all rules
CONTAINER = "bioc-rnaseq-test01new2c"
CONTAINER_DIR = "/home/rstudio/Martina/Snakefile_trial"
```

The container must have acces to the folder you're working on. 

### 6.5 Merging htmls:

For merging the scripts we can write a python script that takes your ouputfolder from snakefile and gets the htmls from there and merges them into a common html with and index that is folder based. For that here's a reference of how the python script should look like.

```{python eval=FALSE}
from pathlib import Path

# Root output directory
html_root = Path("output")
html_files = sorted(html_root.rglob("*.html"))  # Recursively find all HTMLs

# Build tree structure: { folder_path: [html_files] }
from collections import defaultdict

folder_tree = defaultdict(list)
for html_file in html_files:
    relative_path = html_file.relative_to(html_root)
    folder_path = relative_path.parent
    folder_tree[folder_path].append(relative_path)

# Recursive function to render folder structure
def render_folder(folder_path):
    html = '<ul>'
    subfolders = set()
    for file in folder_tree.get(folder_path, []):
        file_id = str(file).replace("/", "_").replace("\\", "_").replace(".", "_")
        html += f'<li><a href="#" onclick="openTab(\'{file_id}\')">{file.name}</a></li>'

    # Detect subfolders
    for path in folder_tree:
        if path.parent == folder_path:
            subfolders.add(path)

    for subfolder in sorted(subfolders):
        html += f'<li><span class="folder" onclick="toggleFolder(this)">{subfolder.name}</span>'
        html += render_folder(subfolder)
        html += '</li>'

    html += '</ul>'
    return html

# Generate tab contents (hidden divs with HTML content)
tab_contents = []
for html_file in html_files:
    relative_path = html_file.relative_to(html_root)
    file_id = str(relative_path).replace("/", "_").replace("\\", "_").replace(".", "_")
    content = html_file.read_text(encoding='utf-8', errors='ignore')
    tab_contents.append(f'''
    <div id="{file_id}" class="tabcontent" style="display:none">
        <h2>{relative_path}</h2>
        {content}
    </div>
    ''')

# Final output HTML
output_html = f"""
<html>
<head>
<style>
ul {{ list-style-type: none; margin-left: 20px; padding-left: 10px; }}
.folder {{ cursor: pointer; font-weight: bold; }}
.folder::before {{ content: "▶ "; display: inline-block; transition: transform 0.2s; }}
.folder.open::before {{ transform: rotate(90deg); }}
.tabcontent {{ display: none; padding: 10px; border: 1px solid #ccc; margin-top: 10px; }}
</style>
<script>
function toggleFolder(element) {{
    element.classList.toggle('open');
    const nextUl = element.nextElementSibling;
    if (nextUl && nextUl.tagName === 'UL') {{
        nextUl.style.display = (nextUl.style.display === 'none') ? 'block' : 'none';
    }}
}}
function openTab(tabId) {{
    document.querySelectorAll('.tabcontent').forEach(el => el.style.display = 'none');
    document.getElementById(tabId).style.display = 'block';
}}
</script>
</head>
<body>
<h1>HTML Folder Navigator</h1>
<div>
    {render_folder(Path('.'))}
</div>
<div>
    {' '.join(tab_contents)}
</div>
</body>
</html>
"""

# Write output index.html at the root of output/
index_path = html_root / "index.html"
index_path.write_text(output_html, encoding="utf-8")
print(f"Generated index with {len(html_files)} HTML files at {index_path}")
```

Then for only producing this specific output, you can use the following command: 

```{bash eval=FALSE}
snakemake output/index.html --cores 1
```

